<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSM Graph Visualization</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map {
            height: 100vh;
            width: 100%;
        }
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            max-width: 300px;
        }
        .node-info {
            margin-top: 10px;
            font-size: 12px;
        }
        .legend {
            position: absolute;
            bottom: 30px;
            right: 10px;
            z-index: 1000;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        .legend-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 8px;
            display: inline-block;
        }
        .legend-point {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            display: inline-block;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 50px;
            z-index: 1000;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        input, button {
            margin: 5px 0;
            padding: 5px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="info-panel">
        <h3>Graph Information</h3>
        <div id="stats">
            <p>Nodes: <span id="node-count">0</span></p>
            <p>Edges: <span id="edge-count">0</span></p>
        </div>
        <div class="node-info" id="node-info">
            Click on a node to see details
        </div>
    </div>
    
    <div class="controls">
        <h3>Path Finding</h3>
        <div>
            <label for="start-node">Start Node ID:</label>
            <input type="text" id="start-node" placeholder="e.g., 12388645022">
        </div>
        <div>
            <label for="end-node">End Node ID:</label>
            <input type="text" id="end-node" placeholder="e.g., 12411606146">
        </div>
        <button id="find-path">Find Path</button>
        <button id="clear-path">Clear Path</button>
        <div id="path-info"></div>
    </div>
    
    <div class="legend">
        <h4>Legend</h4>
        <div class="legend-item">
            <div class="legend-point" style="background-color: #3388ff;"></div>
            <span>Node</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #3388ff;"></div>
            <span>Edge</span>
        </div>
        <div class="legend-item">
            <div class="legend-point" style="background-color: #00ff00;"></div>
            <span>Start Node</span>
        </div>
        <div class="legend-item">
            <div class="legend-point" style="background-color: #ff0000;"></div>
            <span>End Node</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #ff0000;"></div>
            <span>Path</span>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        // Initialize the map centered on Jodhpur
        const map = L.map('map').setView([26.2967, 73.0351], 13);

        // Add OpenStreetMap tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Data structures to store nodes and edges
        const nodes = {};
        const adjacencyList = {};
        let edges = [];
        let pathLayer = null;
        let startMarker = null;
        let endMarker = null;

        // Parse the nodes CSV data
        async function loadNodes() {
            try {
                const response = await fetch('nodes.csv');
                const data = await response.text();
                
                const rows = data.trim().split('\n');
                // Skip header row
                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i].split(',');
                    if (row.length >= 3) {
                        const id = row[0];
                        const lat = parseFloat(row[1]);
                        const lon = parseFloat(row[2]);
                        
                        if (!isNaN(lat) && !isNaN(lon)) {
                            nodes[id] = { id, lat, lon };
                            adjacencyList[id] = [];
                        }
                    }
                }
                
                document.getElementById('node-count').textContent = Object.keys(nodes).length;
                return true;
            } catch (error) {
                console.error('Error loading nodes:', error);
                return false;
            }
        }

        // Parse the edges CSV data
        async function loadEdges() {
            try {
                const response = await fetch('edges.csv');
                const data = await response.text();
                
                const rows = data.trim().split('\n');
                // Skip header row
                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i].split(',');
                    if (row.length >= 3) {
                        const from = row[0];
                        const to = row[1];
                        const distance = parseFloat(row[2]);
                        
                        if (nodes[from] && nodes[to] && !isNaN(distance)) {
                            edges.push({ from, to, distance });
                            
                            // Build adjacency list for path finding
                            adjacencyList[from].push({ node: to, distance });
                        }
                    }
                }
                
                document.getElementById('edge-count').textContent = edges.length;
                return true;
            } catch (error) {
                console.error('Error loading edges:', error);
                return false;
            }
        }

        // Render nodes and edges on the map
        function renderGraph() {
            // Add nodes as markers
            Object.values(nodes).forEach(node => {
                const marker = L.circleMarker([node.lat, node.lon], {
                    radius: 3,
                    fillColor: '#3388ff',
                    color: '#fff',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map);
                
                marker.nodeId = node.id;
                
                marker.on('click', function(e) {
                    showNodeInfo(node.id);
                });
            });
            
            // Add edges as polylines
            edges.forEach(edge => {
                const fromNode = nodes[edge.from];
                const toNode = nodes[edge.to];
                
                if (fromNode && toNode) {
                    L.polyline([[fromNode.lat, fromNode.lon], [toNode.lat, toNode.lon]], {
                        color: '#3388ff',
                        weight: 1,
                        opacity: 0.6
                    }).addTo(map);
                }
            });
        }

        // Show node information in the panel
        function showNodeInfo(nodeId) {
            const node = nodes[nodeId];
            if (node) {
                const neighbors = adjacencyList[nodeId].map(n => {
                    return `<li>Node ${n.node} (${n.distance.toFixed(2)} m)</li>`;
                }).join('');
                
                document.getElementById('node-info').innerHTML = `
                    <h4>Node ${nodeId}</h4>
                    <p>Latitude: ${node.lat.toFixed(6)}</p>
                    <p>Longitude: ${node.lon.toFixed(6)}</p>
                    <p>Connected to ${adjacencyList[nodeId].length} nodes:</p>
                    <ul>${neighbors}</ul>
                `;
            }
        }

        // Dijkstra's algorithm for finding shortest path
        function dijkstra(startId, endId) {
            const distances = {};
            const previous = {};
            const pq = new PriorityQueue();
            
            // Initialize distances
            Object.keys(nodes).forEach(nodeId => {
                distances[nodeId] = Infinity;
                previous[nodeId] = null;
            });
            
            distances[startId] = 0;
            pq.enqueue(startId, 0);
            
            while (!pq.isEmpty()) {
                const current = pq.dequeue().element;
                
                if (current === endId) break;
                
                adjacencyList[current].forEach(neighbor => {
                    const distance = distances[current] + neighbor.distance;
                    
                    if (distance < distances[neighbor.node]) {
                        distances[neighbor.node] = distance;
                        previous[neighbor.node] = current;
                        pq.enqueue(neighbor.node, distance);
                    }
                });
            }
            
            // Reconstruct path
            if (distances[endId] === Infinity) {
                return { path: [], distance: 0 };
            }
            
            const path = [];
            let current = endId;
            
            while (current !== null) {
                path.unshift(current);
                current = previous[current];
            }
            
            return { path, distance: distances[endId] };
        }

        // Priority Queue implementation for Dijkstra's algorithm
        class PriorityQueue {
            constructor() {
                this.values = [];
            }
            
            enqueue(element, priority) {
                this.values.push({ element, priority });
                this.sort();
            }
            
            dequeue() {
                return this.values.shift();
            }
            
            sort() {
                this.values.sort((a, b) => a.priority - b.priority);
            }
            
            isEmpty() {
                return this.values.length === 0;
            }
        }

        // Find and display the shortest path
        function findPath() {
            const startId = document.getElementById('start-node').value;
            const endId = document.getElementById('end-node').value;
            
            if (!nodes[startId]) {
                alert(`Start node ${startId} not found!`);
                return;
            }
            
            if (!nodes[endId]) {
                alert(`End node ${endId} not found!`);
                return;
            }
            
            clearPath();
            
            const { path, distance } = dijkstra(startId, endId);
            
            if (path.length === 0) {
                document.getElementById('path-info').innerHTML = 'No path found between these nodes.';
                return;
            }
            
            // Create path polyline
            const pathCoordinates = path.map(nodeId => [nodes[nodeId].lat, nodes[nodeId].lon]);
            pathLayer = L.polyline(pathCoordinates, {
                color: '#ff0000',
                weight: 4,
                opacity: 0.7
            }).addTo(map);
            
            // Add start and end markers
            startMarker = L.circleMarker([nodes[startId].lat, nodes[startId].lon], {
                radius: 8,
                fillColor: '#00ff00',
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(map);
            
            endMarker = L.circleMarker([nodes[endId].lat, nodes[endId].lon], {
                radius: 8,
                fillColor: '#ff0000',
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(map);
            
            // Zoom to path
            map.fitBounds(pathLayer.getBounds(), { padding: [50, 50] });
            
            // Update path info
            document.getElementById('path-info').innerHTML = `
                <p>Path found: ${path.length} nodes</p>
                <p>Total distance: ${distance.toFixed(2)} meters</p>
            `;
        }

        // Clear the displayed path
        function clearPath() {
            if (pathLayer) {
                map.removeLayer(pathLayer);
                pathLayer = null;
            }
            
            if (startMarker) {
                map.removeLayer(startMarker);
                startMarker = null;
            }
            
            if (endMarker) {
                map.removeLayer(endMarker);
                endMarker = null;
            }
            
            document.getElementById('path-info').innerHTML = '';
        }

        // Initialize the application
        async function init() {
            const nodesLoaded = await loadNodes();
            if (nodesLoaded) {
                const edgesLoaded = await loadEdges();
                if (edgesLoaded) {
                    renderGraph();
                }
            }
        }

        // Event listeners
        document.getElementById('find-path').addEventListener('click', findPath);
        document.getElementById('clear-path').addEventListener('click', clearPath);

        // Start the application
        init();
    </script>
</body>
</html>
